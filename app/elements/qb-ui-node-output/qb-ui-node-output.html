<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../qb-behavior-node-connector/qb-behavior-node-connector.html">
<link rel="import" href="../qb-behavior-self-property/qb-behavior-self-property.html">
<link rel="import" href="../qb-behavior-utils/qb-behavior-utils.html">

<link rel="import" href="../qb-core-i18n/qb-core-i18n.html">
<link rel="import" href="../qb-core-connection-line/qb-core-connection-line.html">

<link rel="import" href="../qb-ui-node-output-outlet/qb-ui-node-output-outlet.html">

<dom-module id='qb-ui-node-output'>
	<style>
		:host{
			display: block;
			position: relative;
			text-align: right;
			width: 100%;
			--handle-height: var(--qb-ui-node-output-handle-height, 20px);
			--handle-offset: var(--qb-ui-node-output-handle-offset, -23px);
			--label-offset: var(--qb-ui-node-output-label-offset, 6px);
			--label-font-size: var(--qb-ui-node-output-label-font-size, 12px);
			height: var(--handle-height);
			@apply(--qb-ui-node-output);
		}
		.label{
			display: block;
			position: relative;
			font-size: var(--label-font-size);
			line-height: var(--handle-height);
			color: var(--qb-text-background-color);
			margin-right:  var(--label-offset);
			@apply(--qb-ui-node-output-label);

		}
		.outlet-container{
			position: absolute;
			top: 0;
			right: 0;
			display: block;
			margin-right: var(--handle-offset);
		}
		#outlet,
		#dragOutlet{

			position: absolute;
			top: 0;
			right: 0;
			--qb-ui-node-input-inlet:{
				width: var(--handle-height);
				height: var(--handle-height);
			};

		}
		#dragOutlet{
			opacity: 0;
		}
		#dragOutlet[drag-status="dragmove"]{
			opacity: 1;
		}
	</style>

	<template>


		<div
			class="label">
			<qb-core-i18n
				key="{{nameKey}}"
				value="{{nameValue}}"></qb-core-i18n>
		</div>
		<div
			class="outlet-container">
			<qb-ui-node-output-outlet
				id="outlet"
				container-output="{{self}}">
			</qb-ui-node-output-outlet>

			<qb-ui-node-output-outlet
				id="dragOutlet"
				container-output="{{self}}"
				drag>
			</qb-ui-node-output-outlet>
		</div>



		<qb-core-connection-line
			id="line"
			canvas="{{svgCanvas}}"
			hidden>
		</qb-core-connection-line>
	</template>
</dom-module>
<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.UINodeOutput = Polymer({
		is: 'qb-ui-node-output',
		behaviors:[
			window.Quirkbot.NodeConnectorBehavior,
			window.Quirkbot.SelfPropertyBehavior,
			window.Quirkbot.UtilsBehavior
		],
		properties: {
			modelController: {
				type: Object
			},
			outlet:{
				type: Object
			},
			dragOutlet:{
				type: Object
			}
		},
		listeners:{
			'dragOutlet.dragend': '_onDragOutletDragend'
		},
		attached: function() {
			this.outlet = this.$.outlet;
			this.dragOutlet = this.$.dragOutlet;
			this.$.line.source = this.outlet;
			this.$.line.destination = this.dragOutlet;
		},
		/**
		 * When dragging finishes, set the outlet back to it's original
		 * position
		 **/
		_onDragOutletDragend: function(){
			// Store the position of the outlet
			var bounding = this.dragOutlet.getBoundingClientRect();
			var centerX = bounding.left + bounding.width * 0.5;
			var centerY = bounding.top + bounding.height * 0.5;

			// Reset the position
			this.dragOutlet.set('data.visualX', 0);
			this.dragOutlet.set('data.visualY', 0);
			this.dragOutlet.fire('dragmove');

			// Search for an inlet on that position
			var value = this.containerNode.data._id + '.' + this.data._id;
			var tree = this.modelController.model.tree;
			for (var i = 0; i < tree.length; i++) {
				var node = tree[i].element;
				if(!this.hitTest(node, centerX, centerY, 10)){
					continue;
				}
				if(typeof node.inputs === 'undefined'){
					continue;
				}
				// Matches node
				for (var j = 0; j < node.inputs.length; j++) {
					var inputData = node.inputs[j].data;
					var input;
					var inlet;
					if(typeof inputData.children === 'undefined'){
						input = node.inputs[j].data.element;

						inlet = input.inlet;
						if(!this.hitTest(input, centerX, centerY) && !this.hitTest(inlet, centerX, centerY)){
							continue;
						}
						// Matches input
						input.set('data.value', value);
						break;
					}
					else{

						for (var k = 0; k < inputData.children.length; k++) {
							input = inputData.children[k].element;
							inlet = input.inlet;
							if(!this.hitTest(input, centerX, centerY) && !this.hitTest(inlet, centerX, centerY)){
								continue;
							}
							// Matches input (in collection)
							input.set('data.value', value);
							break;
						}
					}
				}
				break;
			}

		}
	});
})();
</script>
