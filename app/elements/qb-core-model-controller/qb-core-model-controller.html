<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/promise-polyfill/promise-polyfill-lite.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/iron-localstorage/iron-localstorage.html">
<link rel="import" href="../../bower_components/observe-js/observe-js.html">

<link rel="import" href="../qb-behavior-self-property/qb-behavior-self-property.html">
<link rel="import" href="../qb-core-uuid/qb-core-uuid.html">
<link rel="import" href="../qb-core-i18n/qb-core-i18n.html">

<dom-module id="qb-core-model-controller">
	<template>

		<qb-core-i18n
			key="ide/untitled-program"
			value="{{_ideUntitledProgramName}}"
			hidden>Untitled CODE</qb-core-i18n>

		<iron-localstorage
			name="qb-user"
			value="{{user}}">
		</iron-localstorage>

		<iron-ajax
			id="loader"
			handle-as="json">
		</iron-ajax>

		<iron-ajax
			id="updater"
			handle-as="json"
			content-type="application/json"
			method="PUT">
		</iron-ajax>

	</template>
</dom-module>

<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.CoreModelController = Polymer({
		is: 'qb-core-model-controller',
		behaviors:[
			window.Quirkbot.SelfPropertyBehavior
		],
		properties: {
			model: {
				type: Object,
				notify: true,
				value: function(){
					return {tree:[]};
				}
			},
			_id: {
				type: String,
				value: null,
				reflectToAttribute: true,
				notify: true,
				observer: '__idChanged'
			},
			user: {
				type: Object,
				observer: '_userChanged'
			},
			api: {
				type: String
			},
			verbose: {
				type: String,
				value: ''
			},
			verboseStack: {
				type: Boolean,
				value: false
			}
		},
		observers: [
			'_modelObserver(model.*)'
		],
		listeners:{
			'setupStart' : '_onSetupStart',
			'setupSuccess' : '_onSetupSuccess',
			'setupError' : '_onSetupError',
			'syncStart' : '_onSyncStart',
			'syncSuccess' : '_onSyncSuccess',
			'syncError' : '_onSyncError',
			'addToProfileStart' : '_onAddToProfileStart',
			'addToProfileSuccess' : '_onAddToProfileSuccess',
			'addToProfileError' : '_onAddToProfileError'
		},
		_modelObserver: function(){

		//	console.log('_modelObserver ****************************************', JSON.stringify(this.model))
		},
		_userChanged: function(){
		//	console.log('_userChanged', JSON.stringify(user))
		},
		ready: function(){
			/**
			 * Set a global MODEL for debug
			 */
			window.MODEL = this;
		},
		setup: function(_id){
			var promise = function (resolve, reject) {
				// Set the _id property
				if(this._id !== _id){
					this._id = _id;
				}

				// ID same as the current model, nothing to do here
				if(_id && (_id === this.model._id ) ){
					return resolve('nothing-to-do');
				}

				if(this.isBusy('setup')){
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: 'setup',
						message: 'System is busy.'
					};
					this._log('error', rejectMessage);
					this.fire('setupError', 'busy');
					reject(rejectMessage);
					return;
				}

				if(this.model && this.model.doingSetup){
					this._log('warning', 'Trying to change the _id during the setup process. New _id will be stored and reapplied as soon as the setup process finishes.', _id);
					this.pendingId = _id;
					return resolve('pending-id');
				}

				this.fire('setupStart', _id ? _id : '');



				// Check if there is a user
				this._guaranteeUserExists()
				.then(function(){
					// User is logged in
					if(!_id){
						// No program ID
						this._createEmptyProgram()
						.then(this._createNewId.bind(this))
						.then(function(){
							this.fire('setupSuccess', 'new-program');
							resolve('new-program');
						}.bind(this));
						return;
					}
					// There is a program ID, try lo load it
					this._loadRemotely()
					.then(function(){
						// Loaded. Check if user owns the program
						this._guaranteeUserOwnsProgram()
						.then(function(){
							// Yes, End of process
							this.fire('setupSuccess', 'existing-program');
							resolve('existing-program');
						}.bind(this))
						.catch(function(){
							// User doesn't own the program
							this._createNewId()
							// End of process
							.then(function(){
								this.fire('setupSuccess', 'not-in-profile');
								resolve('not-in-profile');
							}.bind(this));
						}.bind(this));
					}.bind(this))
					.catch(function(error){
						// Could not load remotely, resolve correct error
						var type;
						if(error.errorCode === 1){
							type = 'not-found';
						}
						else {
							type = 'offline';
						}
						var rejectMessage = {
							element: 'qb-core-model-controller',
							method: 'setup',
							message: 'Error trying to load remotely.',
							payload: arguments
						};
						this._log('error', rejectMessage);
						this.fire('setupError', type);
						reject(rejectMessage);
					}.bind(this));
				}.bind(this))
				.catch(function(){
					// No user
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: 'setup',
						message: 'There is no user..',
						payload: arguments
					};
					this._log('error', rejectMessage);
					this.fire('setupError', 'no-user');
					reject(rejectMessage);
				}.bind(this));
			}.bind(this);
			return new Promise(promise);
		},
		addToProfile:function(){
			var promise = function (resolve, reject) {
				if(this.isBusy()){
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: 'addToProfile',
						message: 'System is busy.'
					};
					this._log('error', rejectMessage);
					this.fire('addToProfileError', 'busy');
					reject(rejectMessage);
					return;
				}

				this.fire('addToProfileStart', this._id);

				// Check if there is a user
				this._guaranteeUserExists()
				.then(function(){
					console.log('user in');
					// User is logged in
					this.set('model.userId',this.user._id);
					this.fire('addToProfileSuccess', '');
					resolve();
				}.bind(this))
				.catch(function(){
					console.log('user out');
					// No user
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: 'addToProfile',
						message: 'There is no user.',
						payload: arguments
					};
					this._log('error', rejectMessage);
					this.fire('addToProfileError', 'no-user');
					reject(rejectMessage);
				}.bind(this));
			}.bind(this);
			return new Promise(promise);
		},
		sync: function(){
			var promise = function (resolve, reject) {

				if(this.isBusy()){
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: 'sync',
						message: 'System is busy.'
					};
					this._log('error', rejectMessage);
					this.fire('syncError', 'busy');
					reject(rejectMessage);
					return;
				}

				this.fire('syncStart', this._id);

				// Check if there is a user
				this._guaranteeUserExists()
				.then(function(){
					// User exists, check if it owns the program
					this._guaranteeUserOwnsProgram()
					.then(function(){
						// User owns the sync with server
						this._putRemotely()
						.then(function(type){
							this.fire('syncSuccess', type);
							resolve(type);
						}.bind(this))
						.catch(function(error){
							// Could not load remotely, resolve correct error
							var type;
							if(error.errorCode === 1){
								type = 'forbidden';
							}
							else {
								type = 'offline';
							}
							// Put failed
							var rejectMessage = {
								element: 'qb-core-model-controller',
								method: 'sync',
								message: 'Error trying to put data on server',
								payload: arguments
							};
							this._log('error', rejectMessage);
							this.fire('syncError', type);
							reject(rejectMessage);
						}.bind(this));
					}.bind(this))
					.catch(function(){
						// No user
						var rejectMessage = {
							element: 'qb-core-model-controller',
							method: 'sync',
							message: 'User does not own the program.',
							payload: arguments
						};
						this._log('error', rejectMessage);
						this.fire('syncError', 'forbidden');
						reject(rejectMessage);
					}.bind(this));


				}.bind(this))
				.catch(function(){
					// No user
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: 'sync',
						message: 'There is no user.',
						payload: arguments
					};
					this._log('error', rejectMessage);
					this.fire('syncError', 'no-user');
					reject(rejectMessage);
				}.bind(this));

			}.bind(this);
			return new Promise(promise);
		},
		isBusy: function(bypass){
			if(!this.model) {
				return false;
			}

			var doingSetup = (bypass === 'setup') ? false : this.model.doingSetup;
			var doingSync = (bypass === 'sync') ? false : this.model.doingSync;
			var doingAddToProfile = (bypass === 'addToProfile') ? false : this.model.doingAddToProfile;

			return (doingSetup || doingSync || doingAddToProfile);
		},
		getRawModel: function () {
			return this._modelToRawData(this.model);
		},
		__idChanged:function(_id){
			this.async(function () {
				this._log('log', {event: '__idChanged', detail: _id});
				this.setup(_id)
				.catch(function(){});
			}.bind(this));
		},
		_reapplyPendingId: function(){
			if(typeof this.pendingId !== 'undefined'){
				this._log('log', 'Reapplying pendingId', this.pendingId);
				var pendingId = this.pendingId;
				delete this.pendingId;
				this._id = pendingId;
				return true;
			}
			return false;
		},
		_createEmptyProgram : function(){
			var promise = function (resolve) {
				var doingSetup = this.model.doingSetup;
				var doingSync = this.model.doingSync;
				var doingAddToProfile = this.model.doingAddToProfile;
				this._replaceModel({
					_id: '',
					title: this._ideUntitledProgramName,
					userId: '',
					modifiedAt: 0,
					doingSync: doingSync,
					doingSetup: doingSetup,
					doingAddToProfile: doingAddToProfile,
					syncError: '',
					setupError: '',
					addToProfileError: '',
					tree:[]
				});

				resolve();
			}.bind(this);
			return new Promise(promise);
		},
		_createNewId : function(){
			var promise = function (resolve) {
				var id = window.uuid.v4();
				this.set('model._id', id);
				this._id = id;
				resolve();
			}.bind(this);
			return new Promise(promise);
		},
		_guaranteeUserExists : function(){
			var promise = function (resolve, reject) {
				if(this.user && this.user._id){
					resolve(this.user);
				}
				else{
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_guaranteeUserExists',
						message: '{{user}} is not defined'
					};
					this._log('log', rejectMessage);
					reject(rejectMessage);
				}
			}.bind(this);
			return new Promise(promise);
		},
		_guaranteeUserOwnsProgram : function(){
			var promise = function (resolve, reject) {
				if(this.model.userId !== this.user._id){
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_guaranteeUserOwnsProgram',
						message: '_id does not match model.userId'
					};
					this._log('log', rejectMessage);
					reject(rejectMessage);
				}
				else {
					resolve();
				}

			}.bind(this);
			return new Promise(promise);
		},
		_loadLocally : function(){
			var promise = function (resolve, reject) {
				var raw = window.localStorage.getItem('qb_' + this._id);
				if( raw !== null){
					try {
						var model = JSON.parse(raw);
						this._replaceModel(this._rawDataToModel(model));
						resolve();
					} catch(e) {
						var rejectMessage = {
							element: 'qb-core-model-controller',
							method: '_loadLocally',
							message: 'Could not parse stored data to JSON.',
							payload: e
						};
						this._log('error', rejectMessage);
						reject(rejectMessage);
					}
				}
				else{
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_loadLocally',
						message: 'Localstorage for this id is empty'
					};
					this._log('warning', rejectMessage);
					reject(rejectMessage);
				}
			}.bind(this);
			return new Promise(promise);
		},
		_loadRemotely : function(){
			var promise = function (resolve, reject) {
				if(!this.api ){
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_loadRemotely',
						errorCode: 2, // unhadled
						message: '{{api}} is not defined.'
					};
					this._log('error', rejectMessage);
					reject(rejectMessage);
					return;
				}

				// Try to load data from the api endpoint
				this.$.loader.url = this.api + '/' + this._id;

				var onResponse = function(event){
					clearTimeout(timer);
					this.$.loader.removeEventListener('response', onResponse);
					if(!event.detail.response || event.detail.response.status !== 'ok'){
						var rejectMessageNullResponse = {
							element: 'qb-core-model-controller',
							method: '_loadRemotely.onResponse',
							errorCode: 2, // unhanlded
							message: 'Response was null or invalid. Server is not responding correctly.'
						};
						this._log('error', rejectMessageNullResponse);
						reject(rejectMessageNullResponse);
						return;
					}
					if(!event.detail.response.success){
						var rejectMessage404 = {
							element: 'qb-core-model-controller',
							method: '_loadRemotely.onResponse',
							errorCode: 1, // not found
							message: 'Program not found.'
						};
						this._log('warning', rejectMessage404);
						reject(rejectMessage404);
						return;
					}

					// Loaded successfully!
					this._replaceModel(this._rawDataToModel(event.detail.response.result));
					resolve();
				}.bind(this);

				this.$.loader.addEventListener('response', onResponse);

				var onError = function(event){
					clearTimeout(timer);
					this.$.loader.removeEventListener('error', onError);


					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_loadRemotely.onError',
						errorCode: 2, // unhadled
						message: 'Request failed.',
						payload: event.detail
					};
					this._log('error', rejectMessage);
					reject(rejectMessage);
				}.bind(this);

				this.$.loader.addEventListener('error', onError);

				var timer = setTimeout(function(){
					request.abort();
				}.bind(this), 5000);
				var request = this.$.loader.generateRequest();

			}.bind(this);
			return new Promise(promise);
		},
		_saveLocally : function(){
			var promise = function (resolve, reject) {
				try {
					if (this.model === null) {
						window.localStorage.removeItem('qb_'+this._id);
					} else {
						window.localStorage.setItem('qb_'+this._id, JSON.stringify(this.model));
					}
					resolve();
				}
				catch(e) {
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_saveLocally',
						message: 'localStorage could not be saved. Safari incoginito mode?',
						payload: e
					};
					this._log('error', rejectMessage);
					reject(rejectMessage);
				}
			}.bind(this);
			return new Promise(promise);
		},
		_putRemotely : function(){
			var promise = function (resolve, reject) {
				if(!this.api ){
					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_putRemotely',
						errorCode: 2, // unhadled
						message: '{{api}} is not defined.'
					};
					this._log('error', rejectMessage);
					reject(rejectMessage);
					return;
				}

				// Try to load data from the api endpoint
				this.$.updater.url = this.api + '/' + this._id;
				this.$.updater.body = JSON.stringify(this._modelToRawData(this.model));

				var onResponse = function(event){
					clearTimeout(timer);
					this.$.updater.removeEventListener('response', onResponse);
					if(!event.detail.response || event.detail.response.status !== 'ok'){
						var rejectMessageNullResponse = {
							element: 'qb-core-model-controller',
							method: '_putRemotely.onResponse',
							errorCode: 2, // unhanlded
							message: 'Response was null or invalid. Server is not responding correctly.'
						};
						this._log('error', rejectMessageNullResponse);
						reject(rejectMessageNullResponse);
						return;
					}
					if(!event.detail.response.success){
						var rejectMessage404 = {
							element: 'qb-core-model-controller',
							method: '_putRemotely.onResponse',
							errorCode: 1, // server error
							message: 'Server response has no success.'
						};
						this._log('error', rejectMessage404);
						reject(rejectMessage404);
						return;
					}

					// Loaded successfully!
					var result = event.detail.response.result;
					var resultType;
					if(result._id !== this._id){
						// The id from the server is different, this means that
						// the program only existed locally, and now was created
						// on the server too.
						// We replace the local id with the server one.
						resultType = 'created-on-server';
						var programIndex = this.user.programs.indexOf(this._id);
						if(programIndex !== -1){
							this.splice('user.programs', programIndex, 1);
						}
						this.push('user.programs', result._id);
						this.set('model._id', result._id);
						this._id = result._id;
					}
					else if(result.modifiedAt > this.model.modifiedAt){
						// Server data is more recent, so we replace the local
						// data with it.
						resultType = 'from-server';
						this._replaceModel(this._rawDataToModel(event.detail.response.result));
					}
					else{
						// Local data is more recent then server's data.
						// (Server should have replaced it's data)
						resultType = 'to-server';
					}
					resolve(resultType);

				}.bind(this);

				this.$.updater.addEventListener('response', onResponse);

				var onError = function(event){
					clearTimeout(timer);
					this.$.updater.removeEventListener('error', onError);


					var rejectMessage = {
						element: 'qb-core-model-controller',
						method: '_putRemotely.onError',
						errorCode: 2, // unhadled
						message: 'Request failed.',
						payload: event.detail
					};
					this._log('error', rejectMessage);
					reject(rejectMessage);
				}.bind(this);

				this.$.updater.addEventListener('error', onError);

				var timer = setTimeout(function(){
					request.abort();
				}.bind(this), 5000);

				var request = this.$.updater.generateRequest();

			}.bind(this);
			return new Promise(promise);
		},
		_rawDataToModel : function(data){
			this._log('warning', '_rawDataToModel', 'TODO: implement this :)');
			var model = JSON.parse(JSON.stringify(data));
			model.doingSetup = this.model.doingSetup;
			model.doingSync = this.model.doingSync;
			model.doingAddToProfile = this.model.doingAddToProfile;
			return model;
		},
		_modelToRawData : function(model){
			var safeModel = {};
			Object.keys(model).forEach(function(key){
				safeModel[key] = model[key];
			});

			delete safeModel.tree;
			var safeTree = [];
			this.model.tree.forEach(function(node){
				var safeNode = {};
				safeTree.push(safeNode);
				Object.keys(node).forEach(function(key){
					safeNode[key] = node[key];
				});
				delete safeNode.element;

				delete safeNode.inputs;
				if(node.inputs && node.inputs.length){
					safeNode.inputs = [];
					node.inputs.forEach(function(input){
						if(!input.children && typeof input.value === 'undefined'){
							return;
						}

						var safeInput = {};

						Object.keys(input).forEach(function(key){
							safeInput[key] = input[key];
						});
						delete safeInput.element;

						delete safeInput.children;
						if(input.children && input.children.length){
							safeInput.children = [];
							input.children.forEach(function(child){
								if(typeof child.value === 'undefined'){
									return;
								}
								var safeChild = {};
								safeInput.children.push(safeChild);
								Object.keys(child).forEach(function(key){
									safeChild[key] = child[key];
								});
								delete safeChild.element;
							});
						}
						if(safeInput.children && !safeInput.children.length){
							return;
						}
						if(!safeInput.children && typeof input.value === 'undefined'){
							return;
						}

						safeNode.inputs.push(safeInput);
					});
				}
				delete safeNode.outputs;
				if(safeNode.inputs && !safeNode.inputs.length){
					delete safeNode.inputs;
				}
				/*if(node.outputs && node.outputs.length){
					safeNode.outputs = [];
					node.outputs.forEach(function(output){
						var safeOutput = {};
						safeNode.outputs.push(safeOutput);
						Object.keys(output).forEach(function(key){
							safeOutput[key] = output[key];
						})
						delete safeOutput.element;
					})
				}*/
			});
			safeModel.tree = safeTree;
			delete safeModel.doingSync;
			delete safeModel.doingSetup;
			delete safeModel.doingAddToProfile;
			delete safeModel.syncError;
			delete safeModel.setupError;
			delete safeModel.addToProfileError;
			return safeModel;
		},
		_replaceModel: function(data){
			this.set('model._id', data._id || '');
			this.set('model.title', data.title || '');
			this.set('model.userId', data.userId || '');
			this.set('model.modifiedAt', data.modifiedAt || 0);
			this.set('model.doingSync', data.doingSync || false);
			this.set('model.doingSetup', data.doingSetup || false);
			this.set('model.doingAddToProfile', data.doingAddToProfile || false);
			this.set('model.syncError', data.syncError || '');
			this.set('model.setupError', data.setupError || '');
			this.set('model.addToProfileError', data.addToProfileError || '');

			// For the tree, empty it first, the re-add all elements
			this.splice('model.tree', 0, this.model.tree.length);

			if(data.tree && data.tree.length){
				data.tree.forEach(function(treeItem){
					this.push('model.tree', treeItem);
				}.bind(this));
			}
		},
		_onSetupStart: function(event){
			this.set('model.doingSetup', true);
			if(this.model.setupError){
				this.set('model.setupError', '');
			}
			this._log('log', { event: 'setupStart', detail: event.detail });
		},
		_onSetupSuccess: function(event){
			this.set('model.doingSetup', false);
			if(this.model.setupError){
				this.set('model.setupError', '');
			}
			this._log('log', { event: 'setupSuccess', detail: event.detail });

			if(this._reapplyPendingId()){
				return;
			}
		},
		_onSetupError: function(event){
			this.set('model.doingSetup', false);
			this.set('model.setupError', event.detail);
			this._log('error', { event: 'setupError', detail: event.detail });
			if(this._reapplyPendingId()){
				return;
			}
		},
		_onSyncStart: function(event){
			this.set('model.doingSync', true);
			if(this.model.syncError){
				this.set('model.syncError', '');
			}
			this._log('log', { event: 'syncStart', detail: event.detail });
		},
		_onSyncSuccess: function(event){
			this.set('model.doingSync', false);
			if(this.model.syncError){
				this.set('model.syncError', '');
			}
			this._log('log', { event: 'syncSuccess', detail: event.detail });
		},
		_onSyncError: function(event){
			this.set('model.doingSync', false);
			this.set('model.syncError', event.detail);
			this._log('error', { event: 'syncError', detail: event.detail });
		},
		_onAddToProfileStart: function(event){
			this.set('model.doingAddToProfile', true);
			if(this.model.addToProfileError){
				this.set('model.addToProfileError', '');
			}
			this._log('log', { event: 'addToProfileStart', detail: event.detail });
		},
		_onAddToProfileSuccess: function(event){
			this.set('model.doingAddToProfile', false);
			if(this.model.addToProfileError){
				this.set('model.addToProfileError', '');
			}
			this._log('log', { event: 'addToProfileSuccess', detail: event.detail });
			this.sync()
			.catch(function(){});
		},
		_onAddToProfileError: function(event){
			this.set('model.doingAddToProfile', false);
			this.set('model.addToProfileError', event.detail);
			this._log('error', { event: 'addToProfileError', detail: event.detail });
		},
		_log: function(){
			var level = arguments[0];

			if(!this.verbose) {
				return;
			}
			if(this.verbose === 'error'	&& (level === 'warning' || level === 'log')) {
				return;
			}
			if(this.verbose === 'warning' && level === 'log') {
				return;
			}

			var args = [];
			for (var i = 0; i < arguments.length; i++) {
				args[i] = arguments[i];
			}

			if(level === 'error') {
				args[0] = 'color: red;';
				args.unshift(' %cERROR (<qb-core-model-controller>)');
			}
			if(level === 'warning') {
				args[0] = 'color: orange;';
				args.unshift(' %cWARNING (<qb-core-model-controller>)');
			}
			if(level === 'log') {
				args[0] = 'color: black;';
				args.unshift(' %cLOG (<qb-core-model-controller>)');
			}

			if(this.verboseStack){
				if(Error){
					try{
						var error = new Error();
						if(error.stack){
							args.push(error.stack.toString());
						}
					}
					catch(e){}

				}
			}

			if(level === 'error') {
				return console.log.apply(console, args);
			}
			if(level === 'warning') {
				return console.log.apply(console, args);
			}
			if(level === 'log') {
				return console.log.apply(console, args);
			}
		}
	});
})();
</script>
