<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">

<link rel="import" href="../qb-behavior-node-connector/qb-behavior-node-connector.html">
<link rel="import" href="../qb-behavior-self-property/qb-behavior-self-property.html">
<link rel="import" href="../qb-behavior-utils/qb-behavior-utils.html">

<link rel="import" href="../qb-core-i18n/qb-core-i18n.html">
<link rel="import" href="../qb-core-connection-line/qb-core-connection-line.html">

<link rel="import" href="../qb-ui-node-input-inlet/qb-ui-node-input-inlet.html">

<dom-module id='qb-ui-node-input'>
	<style>
		:host{
			border:solid 1px black;
		};

	</style>

	<template>

		<qb-core-i18n
			key="{{nameKey}}"
			value="{{nameValue}}"
			hidden>
		</qb-core-i18n>

		<qb-ui-node-input-inlet
			id="inlet"
			container-input="{{self}}">
		</qb-ui-node-input-inlet>

		<paper-input
			label="{{nameValue}}"
			placeholder="{{definition.default}}"
			value="{{data.value}}"
			always-float-label>
		</paper-input>


		<span
			id="datalistTemplate"
			hidden$="{{!datalist}}">

			<template
				is="dom-if"
				if="{{datalist}}"
				restamp>

				<paper-menu
					id="menu"
					selected="{{data.value}}"
					attr-for-selected="name">

					<template
						is="dom-repeat"
						items="{{datalist}}">

						<paper-item
							name="{{item.value}}">

							<qb-core-i18n
								key="{{item.translationKey}}"></qb-core-i18n>
						</paper-item>
					</template>
				</paper-menu>
			</template>
		</span>

		<span
			id="sliderTemplate"
			hidden$="{{!range}}">

			<template
				is="dom-if"
				if="{{range}}"
				restamp>

				<paper-slider
					id="slider"
					on-value-change="_sliderValueChanged"
					min="{{range.min}}"
					max="{{range.max}}"
					step="0.01"
					pin>
				</paper-slider>
			</template>
		</span>

		<qb-core-connection-line
			id="line"
			canvas="{{svgCanvas}}"
			source="{{connection.output.element.outlet}}">
		</qb-core-connection-line>

	</template>
</dom-module>
<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.UINodeInput = Polymer({
		is: 'qb-ui-node-input',
		properties:{
			inlet: Object,
			modelController: Object,
			treeManager: Object,
			datalist:{
				type: Array,
				computed: '_computeDatalist(definition)'
			},
			range:{
				type: Object,
				computed: '_computeRange(definition)'
			},
			data: Object,
			connection: Object
		},
		behaviors:[
			window.Quirkbot.NodeConnectorBehavior,
			window.Quirkbot.SelfPropertyBehavior,
			window.Quirkbot.UtilsBehavior
		],
		observers:[
			'_applyDefaultValue(data, definition)',
			'_valueChanged(data.value)',
			'_computeLineSource(data.value)'
		],
		attached: function() {
			this.inlet = this.$.inlet;
			this.$.line.destination = this.inlet;
		},
		_valueChanged: function(value){
			if(!this.definition || !this.data) {
				return;
			}

			// Change value in slider, if it exists
			var slider = this.$.sliderTemplate.querySelector('#slider');
			if(slider && value != '' && !isNaN(value)){
				slider.value = parseFloat(value);
			}

			// Validate
			clearTimeout(this.validateDebouncer);
			this.validateDebouncer = setTimeout(function(){
				this._computeValid(value);
			}.bind(this), 1000);
		},
		_sliderValueChanged: function(){
			var slider = this.$.sliderTemplate.querySelector('#slider');
			if(slider && !isNaN(slider.value)){
				this._setTypedValue('Number', slider.value);
			}
		},
		_computeDatalist: function(definition){
			if(!definition || !definition.validation || definition.validation.type !== 'list' || !definition.validation.data.length) {
				return;
			}
			var datalist = [];
			definition.validation.data.forEach(function(item){
				datalist.push({
					_id: item._id,
					value: item.value,
					translationKey: 'node/connection/datalist/' + item._id
				});
			});
			return datalist;
		},
		_computeRange: function(definition){
			if(!definition || !definition.validation || definition.validation.type !== 'range' || typeof definition.validation.data.min === 'undefined' || typeof definition.validation.data.max === 'undefined') {
				return;
			}

			var range = {
				min:  parseFloat(definition.validation.data.min),
				max:  parseFloat(definition.validation.data.max)
			};

			return range;
		},
		_computeLineSource: function(value){
			clearTimeout(this.connectionLineDebouncer);
			this.connectionLineDebouncer = setTimeout(function(){
				var connection = this._connectionMatch(value);
				if(connection){
					this.connection = connection;
				}
				else{
					this.connection = null;
				}
			}.bind(this), 30);
		},
		_applyDefaultValue: function(data, definition){
			if(!definition || !data) {
				return;
			}

			var oldValue = this.data.value;
			this.async(function(){

				var newValue = oldValue;
				if(typeof oldValue === 'undefined' && this.definition.mandatory	&& typeof this.definition.default !== 'undefined' && this.definition.default !== this.data.value){
					newValue = this.definition.default;
				}

				var slider = this.$.sliderTemplate.querySelector('#slider');
				if(slider && typeof newValue !== 'undefined'){
					slider.value = newValue;
				}

				this._setTypedValue(this.data.type, newValue);

			}.bind(this));
		},
		_computeValid: function(value){
			var _mandatory = this.definition.mandatory;
			var _default;
			if(typeof this.definition.default !== 'undefined'){
				_default = this.definition.default.toString();
			}

			// Check if it is a conection to another node
			if(this._connectionMatch(value)){
				this._setTypedValue('Output', value);
				return;
			}

			// Check if it belongs to datalist
			if(this.datalist){
				var dataListMatch = this._dataListMatch(value);
				if(typeof dataListMatch !=='undefined'){
					this._setTypedValue(isNaN(parseFloat(dataListMatch)) ? 'Constant' : 'Number', dataListMatch);
					return;
				}

				if(_mandatory && typeof _default !=='undefined'){
					this._setTypedValue(isNaN(parseFloat(_default)) ? 'Constant' : 'Number', _default);
					return;
				}
				this._setTypedValue('Number');
				return;

			}

			// Check if it is a number contained in range
			if(this.range){
				if(_mandatory && typeof value === 'undefined'){
					this._setTypedValue('Number');
					return;
				}
				var rangeMatch =  this._rangeMatch(value);
				this._setTypedValue('Number', rangeMatch);
				return;
			}

			// Check if it is a global datalist
			var constantMatch = this._constantMatch(value);
			if(typeof constantMatch !=='undefined'){
				this._setTypedValue('Constant', constantMatch);
				return;
			}

			// Check if it is a valid number
			var ref = parseFloat(value);
			if(isNaN(ref)){
				if(_mandatory && typeof _default !=='undefined'){
					this._setTypedValue(isNaN(parseFloat(_default)) ? 'Constant' : 'Number', _default);
					return;
				}
				console.log('waht', ref	)
				this._setTypedValue('Number');
				return;
			}

			this._setTypedValue('Number', ref);
			return;
		},
		_connectionMatch: function(value){
			if(typeof value ==='undefined') {
				return;
			}

			if(!value) {
				value = '';
			}
			var parts = value.toString().split('.');

			if(parts.length !==2 || !isNaN(parseFloat(parts[0])) || !isNaN(parseFloat(parts[1])) ){
				return;
			}
			// String looks like a connection

			var node = this.findOneObjectByKey(this.modelController.model.tree, '_id', parts[0]);
			if(!node) {
				return;
			}
			// Node found

			var output = this.findOneObjectByKey(node.outputs, '_id', parts[1]);
			if(!output) {
				return;
			}
			// Output found

			var nodeDefinition = this.findOneObjectByKey(this.nodeDefinitions, '_id', node.node);
			if(!nodeDefinition) {
				return;
			}
			// Node definition found

			var outputDefinition = this.findOneObjectByKey(nodeDefinition.outputs, '_id', parts[1]);
			if(!outputDefinition) {
				return;
			}
			// Output definition found

			return {
				node: node,
				output: output,
				nodeDefinition: nodeDefinition,
				outputDefinition: outputDefinition
			};
		},
		_dataListMatch: function(value){
			if(!this.datalist) {
				return;
			}
			if(!value){
				value = '';
			}

			for (var i = 0; i < this.datalist.length; i++) {
				if(this.datalist[i].value.toUpperCase() === value.toUpperCase()){
					return this.datalist[i].value;
				}
			}
		},
		_rangeMatch: function(value){
			if(!this.range) {
				return;
			}
			var _mandatory = this.definition.mandatory;
			var _default;
			if(typeof this.definition.default !== 'undefined'){
				_default = this.definition.default.toString();
			}

			var ref = parseFloat(value);

			if(isNaN(ref)){
				if(_mandatory && typeof _default !== 'undefined') {
					return _default;
				}
				else {
					return;
				}
			}
			if(this.range.min < this.range.max){
				if(ref < this.range.min) {
					return this.range.min;
				}
				else if(ref > this.range.max) {
					return this.range.max;
				}
				else {
					return ref;
				}
			}
			else{
				if(ref > this.range.min) {
					return this.range.min;
				}
				else if(ref < this.range.max) {
					return this.range.max;
				}
				else {
					return ref;
				}
			}
		},
		_constantMatch: function(value){
			if(!value) {
				return;
			}

			var stringValue = value + '';
			stringValue = stringValue.toUpperCase();
			for (var i = 0; i < this.constantDefinitions.length; i++) {
				if(this.constantDefinitions[i].toUpperCase() === stringValue){
					return this.constantDefinitions[i];
				}
			}
		},
		_setTypedValue: function(type, value){
			if(typeof value !== 'undefined'){
				value = value.toString();
			}
			if(this.data.type !== type){
				this.set('data.type', type);
			}
			if(this.data.value !== value){
				this.set('data.value', value);
			}
		}
	});
})();
</script>
