<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-behaviors/iron-button-state.html">
<link rel="import" href="../../bower_components/iron-behaviors/iron-control-state.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">

<link rel="import" href="../qb-behavior-node-connector/qb-behavior-node-connector.html">
<link rel="import" href="../qb-behavior-self-property/qb-behavior-self-property.html">
<link rel="import" href="../qb-behavior-utils/qb-behavior-utils.html">

<link rel="import" href="../qb-core-i18n/qb-core-i18n.html">
<link rel="import" href="../qb-core-connection-line/qb-core-connection-line.html">

<link rel="import" href="../qb-ui-node-input-inlet/qb-ui-node-input-inlet.html">

<dom-module id='qb-ui-node-input'>
	<style>
		:host{
			display: block;
			@apply(--qb-ui-node-input);
			--qb-ui-node-input-handle-height: 20px;
			--qb-ui-node-input-handle-offset: -10px;
			--qb-ui-node-input-font-size: 12px;
		};
		.label{

			@apply(--qb-ui-node-input-label);
		}
		.handle{
			position: relative;
			display: inline-block;
			margin-left: -10px;

			height: var(--qb-ui-node-input-handle-height);
			/*margin-left: var(--qb-ui-node-input-handle-offset);*/
		}
		.inlet{
			position: absolute;
			top: 0;
			left: 0;
			margin-top: 2px;
			@apply(--qb-ui-node-input-inlet);

			--qb-ui-node-connector-color: var(--qb-blue-transparent);

			--qb-ui-node-input-inlet:{
				width: var(--qb-ui-node-input-handle-height);
				height: var(--qb-ui-node-input-handle-height);
			};
		}

		.value-container{

			border-radius: 999px;
			background-color:  var(--qb-text-background-color);
			padding: 0 0.5em 0 2.4em;
			display: inline-block;
			@apply(--qb-font-code);
			@apply(--qb-ui-node-input-label-theme);
			font-size: var(--qb-ui-node-input-font-size);
			line-height: var(--qb-ui-node-input-handle-height);
			height: var(--qb-ui-node-input-handle-height);
		}


		/* controller */
		:host([active]) .controller{
			display: block;
			@apply(--qb-ui-node-input-controller-active-theme);
		}
		.controller{
			position: absolute;
			width: 200px;
			background-color: white;
			padding: 10px;

			animation: pop-in 0.1s ease-out;
			-webkit-animation: pop-in 0.1s ease-out;

			@apply(--qb-ui-node-input-controller-theme);
		}
		.controller,
		:host([connection-type="Output"]) .controller{
			display: none;
			@apply(--qb-ui-node-input-controller-inactive-theme);
		}
		@-webkit-keyframes pop-in{
			0% {
				opacity: 0;
				-webkit-transform: translate(0,-10px);
			}
			100% {
				opacity: 1;
				-webkit-transform: translate(0,0);
			}
		}
		@keyframes pop-in {
			0% {
				opacity: 0;
				-webkit-transform: translate(0,-10px);
			}
			100% {
				opacity: 1;
				-webkit-transform: translate(0,0);
			}
		}

		.slider{
			width: 100%;
			@apply(--qb-ui-node-input-controller-slider-theme);
		}
		.paper-input{
			font-family: monospace;
		}





	</style>

	<template>

		<qb-core-i18n
			key="{{nameKey}}"
			value="{{nameValue}}"
			hidden>
		</qb-core-i18n>


		<div
			class="label">{{name}}</div>

		<div
			class="handle">

			<div
				class="value-container">
				&nbsp;
				<span
					hidden$="{{hideValue}}">{{data.value}}</span>
				<span
					hidden$="{{hideDefault}}">{{definition.default}}</span>
			</div>
			<qb-ui-node-input-inlet
				id="inlet"
				class="inlet"
				connection-type="[[connectionType]]"
				container-input="{{self}}">
			</qb-ui-node-input-inlet>
		</div>

		<div
			id="templateContainer"
			class="controller">

			<template
				is="dom-if"
				if="{{inputTemplate}}"
				restamp>
				<paper-input
					class="text-input"
					value="{{data.value}}"
					no-label-float>
				</paper-input>
			</template>

			<template
				is="dom-if"
				if="{{datalistTemplate}}"
				restamp>

				<paper-menu
					id="menu"
					class="menu"
					selected="{{data.value}}"
					attr-for-selected="name">

					<template
						is="dom-repeat"
						items="{{datalist}}">

						<paper-item
							name="{{item.value}}">

							<qb-core-i18n
								key="{{item.translationKey}}"></qb-core-i18n>
						</paper-item>
					</template>
				</paper-menu>
			</template>

			<template
				is="dom-if"
				if="{{rangeTemplate}}"
				restamp>

				<paper-slider
					id="slider"
					class="slider"
					on-value-change="_sliderValueChanged"
					min="{{range.min}}"
					max="{{range.max}}"
					step="0.01"
					pin>
				</paper-slider>
			</template>
		</div>

		<qb-core-connection-line
			id="line"
			canvas="{{svgCanvas}}"
			source="{{connection.output.element.outlet}}">
		</qb-core-connection-line>

	</template>
</dom-module>
<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.UINodeInput = Polymer({
		is: 'qb-ui-node-input',
		properties:{

			inlet: Object,
			modelController: Object,
			treeManager: Object,
			datalistTemplate: Boolean,
			rangeTemplate: Boolean,
			inputTemplate: Boolean,
			hideDefault:{
				type: Boolean,
				computed: '_computeHideDefault(data.value)'
			},
			hideValue:{
				type: Boolean,
				computed: '_computeHideValue(data.value)'
			},
			connectionType:{
				type: String,
				reflectToAttribute: true
			},
			datalist:{
				type: Array,
				computed: '_computeDatalist(definition)'
			},
			range:{
				type: Object,
				computed: '_computeRange(definition)'
			},
			data: Object,
			connection: Object
		},
		behaviors:[
			Polymer.IronButtonState,
			Polymer.IronControlState,
			window.Quirkbot.NodeConnectorBehavior,
			window.Quirkbot.SelfPropertyBehavior,
			window.Quirkbot.UtilsBehavior
		],
		observers:[
			'_applyDefaultValue(data, definition)',
			'_valueChanged(data.value)',
			'_computeLineSource(data.value)',
			'_computeTemplates(definition)',
			'_computeConnectionType(data.type)',
			'_computeConnectionType(definition)'
		],
		attached: function() {
			this.toggles = true;
			this.inlet = this.$.inlet;
			this.$.line.destination = this.inlet;
		},
		_valueChanged: function(value){
			if(!this.definition || !this.data) {
				return;
			}

			// Change value in slider, if it exists
			var slider = this.$.templateContainer.querySelector('#slider');
			if(slider && value !== '' && value !== null && !isNaN(value)){
				slider.value = parseFloat(value);
			}

			// Validate
			clearTimeout(this.validateDebouncer);
			this.validateDebouncer = setTimeout(function(){
				var valid = this._computeValid(value);
				this._setTypedValue(valid.type, valid.value);
			}.bind(this), 1000);
		},
		_sliderValueChanged: function(){
			var slider = this.$.templateContainer.querySelector('#slider');
			if(slider && !isNaN(slider.value)){
				this._setTypedValue('Number', slider.value);
			}
		},
		_computeTemplates: function (definition) {
			if( definition.validation && definition.validation.type === 'list' && definition.validation.data.length) {
				this.datalistTemplate = true;
				this.rangeTemplate = false;
				this.inputTemplate = false;
			}
			else if( definition.validation && definition.validation.type === 'range' && typeof definition.validation.data.min !== 'undefined' && typeof definition.validation.data.max !== 'undefined') {
				this.datalistTemplate = false;
				this.rangeTemplate = true;
				this.inputTemplate = false;
			}
			else{
				this.datalistTemplate = false;
				this.rangeTemplate = false;
				this.inputTemplate = true;
			}
		},
		_computeHideValue: function(value){
			return (typeof value === 'undefined' || value === '');
		},
		_computeHideDefault: function(value){
			return  (typeof value !== 'undefined' && value !== '');
		},
		_computeConnectionType: function(){
			if(typeof this.definition === 'undefined'){
				return;
			}
			if(typeof this.data.type === 'undefined' && (typeof this.data.value === 'undefined' || this.data.value === '')){
				var valid = this._computeValid(this.data.default);
				this.connectionType = valid.type;
			}
			this.connectionType = this.data.type;
		},
		_computeDatalist: function(definition){
			if(!definition || !definition.validation || definition.validation.type !== 'list' || !definition.validation.data.length) {
				return;
			}
			var datalist = [];
			definition.validation.data.forEach(function(item){
				datalist.push({
					_id: item._id,
					value: item.value,
					translationKey: 'node/connection/datalist/' + item._id
				});
			});
			return datalist;
		},
		_computeRange: function(definition){
			if(!definition || !definition.validation || definition.validation.type !== 'range' || typeof definition.validation.data.min === 'undefined' || typeof definition.validation.data.max === 'undefined') {
				return;
			}

			var range = {
				min:  parseFloat(definition.validation.data.min),
				max:  parseFloat(definition.validation.data.max)
			};

			return range;
		},
		_computeLineSource: function(value){
			clearTimeout(this.connectionLineDebouncer);
			this.connectionLineDebouncer = setTimeout(function(){
				var connection = this._connectionMatch(value);
				if(connection){
					this.connection = connection;
				}
				else{
					this.connection = null;
				}
			}.bind(this), 30);
		},
		_applyDefaultValue: function(data, definition){
			if(!definition || !data) {
				return;
			}

			var oldValue = this.data.value;
			this.async(function(){

				var newValue = oldValue;
				if(typeof oldValue === 'undefined' && this.definition.mandatory	&& typeof this.definition.default !== 'undefined' && this.definition.default !== this.data.value){
					newValue = this.definition.default;
				}

				var slider = this.$.templateContainer.querySelector('#slider');
				if(slider && typeof newValue !== 'undefined'){
					slider.value = newValue;
				}

				this._setTypedValue(this.data.type, newValue);

			}.bind(this));
		},
		_computeValid: function(value){
			var _mandatory = this.definition.mandatory;
			var _default;
			if(typeof this.definition.default !== 'undefined'){
				_default = this.definition.default.toString();
			}

			// Check if it is a conection to another node
			if(this._connectionMatch(value)){
				return{
					type: 'Output',
					value: value
				};
			}

			// Check if it belongs to datalist
			if(this.datalist){
				var dataListMatch = this._dataListMatch(value);
				if(typeof dataListMatch !=='undefined'){
					return {
						type: isNaN(parseFloat(dataListMatch)) ? 'Constant' : 'Number',
						value: dataListMatch
					};
				}

				if(_mandatory && typeof _default !=='undefined'){
					return {
						type: isNaN(parseFloat(_default)) ? 'Constant' : 'Number',
						value:_default
					};
				}
				return {
					type: 'Number'
				};

			}

			// Check if it is a number contained in range
			if(this.range){
				if(_mandatory && typeof value === 'undefined'){
					return {
						type: 'Number'
					};
				}
				var rangeMatch =  this._rangeMatch(value);
				return {
					type: 'Number',
					value: rangeMatch
				};
			}

			// Check if it is a global datalist
			var constantMatch = this._constantMatch(value);
			if(typeof constantMatch !=='undefined'){
				return {
					type: 'Constant',
					value: constantMatch
				};
			}

			// Check if it is a valid number
			var ref = parseFloat(value);
			if(isNaN(ref)){
				if(_mandatory && typeof _default !=='undefined'){
					return {
						type: isNaN(parseFloat(_default)) ? 'Constant' : 'Number',
						value: _default
					};
				}
				return {
					type: 'Number'
				};
			}

			return {
				type: 'Number',
				value: ref
			};
		},
		_connectionMatch: function(value){
			if(typeof value ==='undefined') {
				return;
			}

			if(!value) {
				value = '';
			}
			var parts = value.toString().split('.');

			if(parts.length !==2 || !isNaN(parseFloat(parts[0])) || !isNaN(parseFloat(parts[1])) ){
				return;
			}
			// String looks like a connection

			var node = this.findOneObjectByKey(this.modelController.model.tree, '_id', parts[0]);
			if(!node) {
				return;
			}
			// Node found

			var output = this.findOneObjectByKey(node.outputs, '_id', parts[1]);
			if(!output) {
				return;
			}
			// Output found

			var nodeDefinition = this.findOneObjectByKey(this.nodeDefinitions, '_id', node.node);
			if(!nodeDefinition) {
				return;
			}
			// Node definition found

			var outputDefinition = this.findOneObjectByKey(nodeDefinition.outputs, '_id', parts[1]);
			if(!outputDefinition) {
				return;
			}
			// Output definition found

			return {
				node: node,
				output: output,
				nodeDefinition: nodeDefinition,
				outputDefinition: outputDefinition
			};
		},
		_dataListMatch: function(value){
			if(!this.datalist) {
				return;
			}
			if(!value){
				value = '';
			}

			for (var i = 0; i < this.datalist.length; i++) {
				if(this.datalist[i].value.toUpperCase() === value.toUpperCase()){
					return this.datalist[i].value;
				}
			}
		},
		_rangeMatch: function(value){
			if(!this.range) {
				return;
			}
			var _mandatory = this.definition.mandatory;
			var _default;
			if(typeof this.definition.default !== 'undefined'){
				_default = this.definition.default.toString();
			}

			var ref = parseFloat(value);

			if(isNaN(ref)){
				if(_mandatory && typeof _default !== 'undefined') {
					return _default;
				}
				else {
					return;
				}
			}
			if(this.range.min < this.range.max){
				if(ref < this.range.min) {
					return this.range.min;
				}
				else if(ref > this.range.max) {
					return this.range.max;
				}
				else {
					return ref;
				}
			}
			else{
				if(ref > this.range.min) {
					return this.range.min;
				}
				else if(ref < this.range.max) {
					return this.range.max;
				}
				else {
					return ref;
				}
			}
		},
		_constantMatch: function(value){
			if(!value) {
				return;
			}

			var stringValue = value + '';
			stringValue = stringValue.toUpperCase();
			for (var i = 0; i < this.constantDefinitions.length; i++) {
				if(this.constantDefinitions[i].toUpperCase() === stringValue){
					return this.constantDefinitions[i];
				}
			}
		},
		_setTypedValue: function(type, value){
			if(typeof value !== 'undefined' && value !== null){
				value = value.toString();
			}
			if(this.data.type !== type){
				this.set('data.type', type);
			}
			if(this.data.value !== value){
				this.set('data.value', value);
			}
		}
	});
})();
</script>
