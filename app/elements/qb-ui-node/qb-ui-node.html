<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/observe-js/observe-js.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">

<link rel="import" href="../qb-behavior-draggable/qb-behavior-draggable.html">
<link rel="import" href="../qb-behavior-utils/qb-behavior-utils.html">
<link rel="import" href="../qb-behavior-self-property/qb-behavior-self-property.html">

<link rel="import" href="../qb-core-uuid/qb-core-uuid.html">

<link rel="import" href="../qb-core-i18n/qb-core-i18n.html">
<link rel="import" href="../qb-ui-node-input/qb-ui-node-input.html">
<link rel="import" href="../qb-ui-node-input-collection/qb-ui-node-input-collection.html">
<link rel="import" href="../qb-ui-node-output/qb-ui-node-output.html">

<dom-module id='qb-ui-node'>
	<style>
		:host{
			display: block;
			position: absolute;
			@apply(--qb-ui-node-host-theme);
		}
		.name{
			@apply(--qb-ui-node-name-theme);
		}
		.inputs{
			@apply(--qb-ui-node-connection-theme);
			@apply(--qb-ui-node-inputs-theme);
		}
		.outputs{
			@apply(--qb-ui-node-connection-theme);
			@apply(--qb-ui-node-outputs-theme);
		}

	</style>

	<template>

		<qb-core-uuid
			id="uuid">
		</qb-core-uuid>

		<paper-icon-button
			id="deleteButton"
			icon="highlight-off"
			alt="remove"
			on-down="_onDeletePress">
		</paper-icon-button>

		<div class='name'>
			<iron-icon icon="{{iconName}}"></iron-icon>
			<qb-core-i18n key="{{nameKey}}"></qb-core-i18n>
		</div>

		<div class='inputs'>
			<template
				is="dom-repeat"
				items="{{inputs}}">

				<template
					is="dom-if"
					if="{{!item.definition.multiple}}"
					restamp>
					<qb-ui-node-input
						svg-canvas="{{svgCanvas}}"
						container-node="{{self}}"
						model-controller="{{modelController}}"
						node-definitions="{{nodeDefinitions}}"
						constant-definitions="{{constantDefinitions}}"
						definition="{{item.definition}}"
						data="{{item.data}}">
					</qb-ui-node-input>
				</template>

				<template
					is="dom-if"
					if="{{item.definition.multiple}}"
					restamp>

					<qb-ui-node-input-collection
						svg-canvas="{{svgCanvas}}"
						container-node="{{self}}"
						model-controller="{{modelController}}"
						node-definitions="{{nodeDefinitions}}"
						constant-definitions="{{constantDefinitions}}"
						definition="{{item.definition}}"
						data="{{item.data}}">
					</qb-ui-node-input-collection>
				</template>

			</template>
		</div>

		<div class='outputs'>
			<template
				is="dom-repeat"
				items="{{outputs}}">

				<qb-ui-node-output
					svg-canvas="{{svgCanvas}}"
					container-node="{{self}}"
					model-controller="{{modelController}}"
					node-definitions="{{nodeDefinitions}}"
					constant-definitions="{{constantDefinitions}}"
					definition="{{item.definition}}"
					data="{{item.data}}">
				</qb-ui-node-output>

			</template>
		</div>


	</template>
</dom-module>
<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.UINode = Polymer({
		is: 'qb-ui-node',
		properties: {
			svgCanvas: Object,
			modelController: Object,
			treeManager: Object,
			nodeDefinitions: Object,
			constantDefinitions: Object,
			definition: Object,
			data: {
				type: Object,
				observer: '_dataChanged'
			},
			inputs: Array,
			outputs: Array,
			nameKey: {
				type: String,
				computed: '_computeNameKey(definition)'
			},
			iconName: {
				type: String,
				computed: '_computeIconName(definition)'
			}
		},
		behaviors:[
			window.Quirkbot.DraggableBehavior,
			window.Quirkbot.SelfPropertyBehavior,
			window.Quirkbot.UtilsBehavior
		],
		observers:[
			'_dataAndNodeDefinitionsChanged(data, nodeDefinitions)',
			'_constrainDrag(data.visualX, data.visualY)'
		],
		_dataChanged: function(){
			this.data.element = this;
		},
		_dataAndNodeDefinitionsChanged: function(data, nodeDefinitions){
			if(!data || !nodeDefinitions) {
				return;
			}
			var definition;
			for (var i = 0; i < nodeDefinitions.length; i++) {
				if(nodeDefinitions[i]._id === data.node){
					definition = nodeDefinitions[i];
					break;
				}
			}
			if(!definition) {
				return;
			}

			this.definition = definition;

			this.outputs = [];
			definition.outputs.forEach(function(outputDefinition){
				if(!data.outputs){
					this.set('data.outputs',[]);
				}

				var outputData = this.findObjectByKey(data.outputs, '_id', outputDefinition._id);
				if(!outputData) {
					outputData = {_id: outputDefinition._id};
					this.push('data.outputs',outputData);
				}

				this.push('outputs', {
					definition : outputDefinition,
					data : outputData
				});
			}.bind(this));

			this.inputs = [];
			definition.inputs.forEach(function(inputDefinition){
				if(!data.inputs){
					this.set('data.inputs',[]);
				}

				var inputData = this.findObjectByKey(data.inputs, '_id', inputDefinition._id);
				if(!inputData) {
					inputData = {_id: inputDefinition._id};
					this.push('data.inputs',inputData);
				}

				if(inputDefinition.multiple && !inputData.children){
					inputData.children = [];
				}

				this.push('inputs', {
					definition : inputDefinition,
					data: inputData
				});
			}.bind(this));
		},
		_computeNameKey: function(definition){
			return 'node/name/'+definition._id;
		},
		_computeIconName: function(definition){
			return this.resolveIconName(definition._id, 'quirkbot-nodes');
		},
		_onDeletePress: function(){
			this.treeManager.remove(this.data._id);

		},
		/**
		 * Allows to disable/enable dragging by filtering the track event.
		 *
		 * @return {boolean} - 'true' if tracking should be disabled
		 */
		trackEventFilter: function(e){
			if(e.target.id === 'sliderKnob') {
				return true;
			}
			if(e.target.id === 'sliderKnobInner') {
				return true;
			}
			if(e.target.id === 'sliderBar') {
				return true;
			}
			if(e.target.id === 'dragOutlet') {
				return true;
			}
			if(e.target.id === 'inlet') {
				return true;
			}

			// This is for shadow dom only, since e.target will be the host
			// element, regardless of how deep in was the targe.
			// We have to check if e.path is falsey since it seems to be a
			// chrome only thing.
			if(e.path){
				if(e.path.length && e.path[0].id === 'sliderKnob') {
					return true;
				}
				if(e.path.length && e.path[0].id === 'sliderKnobInner') {
					return true;
				}
				if(e.path.length && e.path[0].id === 'sliderBar') {
					return true;
				}
				if(e.path.length && e.path[0].id === 'dragOutlet') {
					return true;
				}
				if(e.path.length && e.path[0].id === 'inlet') {
					return true;
				}
			}


			return false;
		},
		/**
		 * Don't allow the node to be dragged to a negative position;
		 */
		_constrainDrag: function(visualX, visualY){
			if(visualX < 0 && this.data){
				this.set('data.visualX', 0);
			}
			if(visualY < 0 && this.data){
				this.set('data.visualY', 0);
			}
		}
	});
})();
</script>
