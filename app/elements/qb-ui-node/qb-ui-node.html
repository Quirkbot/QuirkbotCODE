<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/observe-js/observe-js.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">

<link rel="import" href="../qb-behavior-draggable/qb-behavior-draggable.html">
<link rel="import" href="../qb-behavior-utils/qb-behavior-utils.html">

<link rel="import" href="../qb-core-uuid/qb-core-uuid.html">

<link rel="import" href="../qb-core-i18n/qb-core-i18n.html">
<link rel="import" href="../qb-ui-node-input/qb-ui-node-input.html">
<link rel="import" href="../qb-ui-node-input-collection/qb-ui-node-input-collection.html">
<link rel="import" href="../qb-ui-node-output/qb-ui-node-output.html">

<dom-module id='qb-ui-node'>
	<style>
		:host{
			display: block;
			position: absolute;
			@apply(--qb-ui-node-host-theme);
		}
		.name{
			@apply(--qb-ui-node-name-theme);
		}
		.inputs{
			@apply(--qb-ui-node-connection-theme);
			@apply(--qb-ui-node-inputs-theme);
		}
		.outputs{
			@apply(--qb-ui-node-connection-theme);
			@apply(--qb-ui-node-outputs-theme);
		}

	</style>

	<template>

		<qb-core-uuid
			id="uuid">
		</qb-core-uuid>

		<paper-icon-button
			id="deleteButton"
			icon="highlight-off"
			alt="remove"
			on-down="_onDeletePress">
		</paper-icon-button>

		<div class='name'>
			<qb-core-i18n key="{{nameKey}}"></qb-core-i18n>
		</div>

		<div class='inputs'>
			<template
				is="dom-repeat"
				items="{{inputs}}">

				<template
					is="dom-if"
					if="{{!item.definition.multiple}}"
					restamp>
					<qb-ui-node-input
						svg-canvas="{{svgCanvas}}"
						model-controller="{{modelController}}"
						node-definitions="{{nodeDefinitions}}"
						constant-definitions="{{constantDefinitions}}"
						definition="{{item.definition}}"
						data="{{item.data}}">
					</qb-ui-node-input>
				</template>

				<template
					is="dom-if"
					if="{{item.definition.multiple}}"
					restamp>

					<qb-ui-node-input-collection
						svg-canvas="{{svgCanvas}}"
						model-controller="{{modelController}}"
						node-definitions="{{nodeDefinitions}}"
						constant-definitions="{{constantDefinitions}}"
						definition="{{item.definition}}"
						data="{{item.data}}">
					</qb-ui-node-input-collection>
				</template>

			</template>
		</div>

		<div class='outputs'>
			<template
				is="dom-repeat"
				items="{{outputs}}">
				
				<qb-ui-node-output
					svg-canvas="{{svgCanvas}}"
					model-controller="{{modelController}}"
					node-definitions="{{nodeDefinitions}}"
					constant-definitions="{{constantDefinitions}}"
					definition="{{item.definition}}"
					data="{{item.data}}">
				</qb-ui-node-output>

			</template>
		</div>


	</template>
</dom-module>
<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.UINode = Polymer({
		is: 'qb-ui-node',
		properties: {
			svgCanvas: {
				type: Object
			},
			modelController:{
				type: Object
			},
			nodeDefinitions: {
				type: Object
			},
			constantDefinitions: {
				type: Object
			},
			definition: {
				type: Object
			},
			data: {
				type: Object
			},
			nameKey: {
				type: String,
				computed: '_computeNameKey(definition)'
			}
		},
		behaviors:[
			window.Quirkbot.DraggableBehavior,
			window.Quirkbot.UtilsBehaviour
		],
		observers:[
			'_dataAndNodeDefinitionsChanged(data, nodeDefinitions)'
		],
		_dataChanged: function(){
			this.data.element = this;
		},
		_dataAndNodeDefinitionsChanged: function(data, nodeDefinitions){
			if(!data || !nodeDefinitions) {
				return;
			}
			var definition;
			for (var i = 0; i < nodeDefinitions.length; i++) {
				if(nodeDefinitions[i]._id === data.node){
					definition = nodeDefinitions[i];
					break;
				}
			}
			if(!definition) {
				return;
			}

			this.definition = definition;

			this.outputs = [];
			definition.outputs.forEach(function(outputDefinition){
				if(!data.outputs){
					this.set('data.outputs',[]);
				}

				var outputData = this.findObjectByKey(data.outputs, '_id', outputDefinition._id);
				if(!outputData) {
					outputData = {_id: outputDefinition._id};
					this.push('data.outputs',outputData);
				}

				this.push('outputs', {
					definition : outputDefinition,
					data : outputData
				});
			}.bind(this));

			this.inputs = [];
			definition.inputs.forEach(function(inputDefinition){
				if(!data.inputs){
					this.set('data.inputs',[]);
				}

				var inputData = this.findObjectByKey(data.inputs, '_id', inputDefinition._id);
				if(!inputData) {
					inputData = {_id: inputDefinition._id};
					this.push('data.inputs',inputData);
				}

				if(inputDefinition.multiple && !inputData.children){
					inputData.children = [];
				}

				this.push('inputs', {
					definition : inputDefinition,
					data: inputData
				});
			}.bind(this));
		},
		_computeNameKey: function(definition){
			return 'node/name/'+definition._id;
		},
		_onDeletePress: function(){
			var index = this.findIndexByKey(this.modelController.model.tree, '_id', this.data._id);
			if(index === -1) {
				return;
			}

			// "Disconnect" this node from any inputs that is connected to id
			var disconnectInput = function(input){
				if(input.type !== 'Output') {
					return;
				}

				var parts = input.value.split('.');

				if(parts.length !== 2 || !isNaN(parseFloat(parts[0])) || !isNaN(parseFloat(parts[1])) ) {
					return;
				}

				if(parts[0] === this.data._id){
					input.element.set('data.value', null);
				}
			}.bind(this);
			this.modelController.model.tree.forEach(function(node){
				if(node === this.data) {
					return;
				}
				node.inputs.forEach(function(input){
					disconnectInput(input);
					// check if the input is a collection
					if(!input.children || !input.children.length){
						return;
					}
					input.children.forEach(disconnectInput);
				}.bind(this));
			}.bind(this));

			this.modelController.splice('model.tree', index, 1);

		},
		/**
		 * Allows to disable/enable dragging by filtering the track event.
		 *
		 * @return {boolean} - 'true' if tracking should be disabled
		 */
		trackEventFilter: function(e){
			if(e.target.id === 'sliderKnob') {
				return true;
			}
			if(e.target.id === 'sliderBar') {
				return true;
			}

			// This is for shadow dom only, since e.target will be the host
			// element, regardless of how deep in was the targe.
			// We have to check if e.path is falsey since it seems to be a
			// chrome only thing. 
			if(e.path){
				if(e.path.length && e.path[0].id === 'sliderKnob') {
					return true;
				}
				if(e.path.length && e.path[0].id === 'sliderBar') {
					return true;
				}
			}
			
			
			return false;
		}
	});
})();
</script>
