<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-localstorage/iron-localstorage.html">

<link rel="import" href="../qb-behavior-self-property/qb-behavior-self-property.html">

<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/iron-form/iron-form.html">

<dom-module id="qb-core-auth">
	<template>
		<iron-ajax
			method="POST"
			url="[[tokenUrl]]"
			headers="[[tokenHeaders]]"
			id="tokenAjax">
		</iron-ajax>

		<iron-ajax
			id="apiAjax">
		</iron-ajax>

		<iron-localstorage
			name="qb-accessToken"
			value="{{accessToken}}">
		</iron-localstorage>
		<iron-localstorage
			name="qb-refreshToken"
			value="{{refreshToken}}">
		</iron-localstorage>
		<iron-localstorage
			name="qb-tokenExpires"
			value="{{expires}}">
		</iron-localstorage>

	</template>
</dom-module>
<script>
(function () {
	window.Quirkbot = window.Quirkbot || {};
	window.Quirkbot.CoreAuth = Polymer({
		is: 'qb-core-auth',
		properties: {
			authUrl: {
				type: String
			},
			apiUrl: {
				type: String
			},
			tokenUrl:{
				type: String,
				computed: '_computeTokenUrl(authUrl)'
			},
			tokenHeaders:{
				type: String,
				computed: '_computeTokenHeaders(clientId)'
			},
			clientId: {
				type: String
			},
			user: {
				type: String
			},
			password: {
				type: String
			},
			accessToken: {
				type: String,
				notify: true
			},
			refreshToken: {
				type: String,
				notify: true
			},
			expires: {
				type: Number,
				notify: true
			}
		},
		observers:[
			'_scheduleRefresh(expires)'
		],
		behaviors:[
			window.Quirkbot.SelfPropertyBehavior
		],
		attached: function(){
			this._processInitialValues();
		},
		authenticate: function(user, password){
			user = user || '';
			password = password || '';
			this.$.tokenAjax.body = {
				'grant_type': 'password',
				'username' : user,
				'password': password
			};
			return this._requestToken();
		},
		refresh: function(){
			var refreshToken = this.refreshToken || '';
			this.$.tokenAjax.body = {
				'grant_type': 'refresh_token',
				'refresh_token' : refreshToken
			};
			return this._requestToken();
		},
		apiCall: function (method, path, data, blockAuthRetry) {
			return new Promise(function (resolve, reject) {
				this.$.apiAjax.headers = {
					'Content-Type' : 'application/x-www-form-urlencoded',
					'Authorization' : 'Bearer '+ this.accessToken
				};
				this.$.apiAjax.method = method;
				this.$.apiAjax.url = this.apiUrl + '/' + path;
				if(data){
					this.$.apiAjax.body = data;
				}
				this._request(this.$.apiAjax)
				.then(resolve)
				.catch(function (error) {
					if(!blockAuthRetry && error.code === 'NOT_AUTHENTICATED'){
						// Try to refresh the access token...
						this.refresh()
						.then(function() {
							// Got access, now remake the call
							this.apiCall(method, path, data, true)
							.then(resolve)
							.catch(function(error){
								this.fire('api-error', error);
								reject(error);
							}.bind(this));
						}.bind(this))
						.catch(reject);
					}
					else{
						this.fire('api-error', error);
						reject(error);
					}

				}.bind(this));
			}.bind(this));
		},
		_requestToken: function () {
			clearTimeout(this._scheduleRefreshTimer);
			return new Promise(function (resolve, reject) {
				this._request(this.$.tokenAjax)
				.then(function(response){
					// Annoying juggle to get around lint problems with underscore_names
					var accessTokenKey = 'access_token';
					this.accessToken = response[accessTokenKey];

					var refreshTokenKey = 'refresh_token';
					this.refreshToken = response[refreshTokenKey];

					var expiresKey = 'expires_in';
					this.expires = Date.now() + (response[expiresKey] * 1000);

					this.fire('authenticate', this);
					resolve();
				}.bind(this))
				.catch(function(error){
					this.fire('authenticate-error', error);
					reject(error);
				}.bind(this));
			}.bind(this));
		},
		_request: function (ajax) {
			return new Promise(function(resolve, reject) {
				var onResponse = function(e){
					clearTimeout(timer);
					ajax.removeEventListener('response', onResponse);
					ajax.removeEventListener('error', onError);
					if(!e.detail.response){
						reject({
							"message": "Could not get any response",
							"code": "CONNECTION_REFUSED",
							"data": {}
						});
					}
					else{
						resolve(e.detail.response);
					}
				}.bind(this);
				ajax.addEventListener('response', onResponse);

				var onError = function(e){
					clearTimeout(timer);
					ajax.removeEventListener('response', onResponse);
					ajax.removeEventListener('error', onError);
					var response;
					if(e.detail.response){
						response = e.detail.response;
					}
					else if(e.detail.request && e.detail.request.xhr && e.detail.request.xhr.response){
						response = e.detail.request.xhr.response;
					}
					reject(response);
				}.bind(this);

				ajax.addEventListener('error', onError);
				var request = ajax.generateRequest();
				var timer = setTimeout(function(){
					request.abort();
				}.bind(this), 10000);

			}.bind(this));
		},
		_computeTokenUrl: function(authUrl){
			return authUrl + '/token';
		},
		_computeTokenHeaders: function(clientId){
			return {
				'Content-Type' : 'application/x-www-form-urlencoded',
				'Authorization' : 'Basic '+ clientId
			};
		},
		_scheduleRefresh: function(expires, force){
			if(!expires && !force){
				return;
			}
			var delay;
			if(force){
				delay = 0;
			}
			else{
				var expiration = expires - 30000;
				if(expiration < Date.now()){
					delay = 0;
				}
				else{
					delay = expiration - Date.now();
				}
			}

			this._scheduleRefreshTimer =  setTimeout(this.refresh.bind(this), delay);
		},
		_processInitialValues: function(){
			setTimeout(function () {
				if(this.expires > Date.now() && this.accessToken && this.refreshToken){
					this.fire('authenticate', this);
				}
			}.bind(this), 10);

		},

	});
})();
</script>
