<link rel="import" href="../qb.html">
<script src="ChromeExtensionAPIClient.js"></script>


<dom-module	id="qb-browser-extension">
</dom-module>

<script>
(function () {
	Polymer({
		is: 'qb-browser-extension',
		hostAttributes:{
			hidden: true
		},
		properties: {
			extensionId: {
				type: String,
				value: "ackaalhbfjagidmjlhlokoblhbnahegd",
				observer: 'extensionIdChanged',
			},
			model: {
				type: Object,
				value: {quirkbots:[]},
				notify: true,
				observer: 'modelChanged'
			},
			connected: {
				type: Boolean,
				value: false,
				notify: true
			}
		},
		adapter: {},
		created: function(){
			// Start monitoring extension
			this.monitorExtensionConnection()
		},
		extensionIdChanged : function(extensionId){
			this.connectToExtension();
		},
		connectToExtension: function(){
			var self = this;
			self.connected = false;
			// Clear previous event listeners
			if(self.adapter.modelChange)
				self.adapter.modelChange.remove(self.onAdapterModelChange)
			
			// Google Chrome
			if(typeof chrome !== 'undefined'){
				var api = new ChromeExtensionAPIClient(self.extensionId);
				self.adapter.ping = api.generateMethod('ping');
				this.adapter.compile = api.generateMethod('compile');
				this.adapter.upload = api.generateMethod('upload');
				this.adapter.modelChange = api.generateEvent('modelChange');
			}
		},
		monitorExtensionConnection: function(){
			var self = this;
			var interval = 1000;
			// Ping the extension to see if we are connected. We will not get
			// an error in case we can't access to exthension (eg. running from
			// an unauthrized domain), so we need to timeout to notify failure
			var timeout = setTimeout(function () {
				if(self.connected){
					console.log('Disconnected from extensionId: ' + self.extensionId)
					self.connected = false;
					self.model = {}
				}
				self.monitorExtensionConnection()
			}, interval)

			if(!self.adapter.ping) return;
			self.adapter.ping()
			.then(function(response){
				if(!self.connected){
					console.log('Connected to extensionId: ' + self.extensionId)
					self.connected = true;
					// Now we are save to bind the adapter to the extension
					self.adapter.modelChange.add(self.onAdapterModelChange.bind(self));
				}
				clearTimeout(timeout)
				setTimeout(self.monitorExtensionConnection.bind(self), interval);
			})
			.catch(function(error){
				// If we were explitly rejected, the extension must be booting up
				console.log(error)
				if(self.connected){
					console.log('Disconnected from extensionId: ' + self.extensionId)
					self.connected = false;
					self.model = {}
				}
				clearTimeout(timeout)
				setTimeout(self.monitorExtensionConnection.bind(self), interval);
			})
		},
		onAdapterModelChange: function(model){
			this.model = model;
		},
		modelChanged: function(){
			//console.log(this.model)
		},
		compile: function( source ){
			return this.adapter.compile(source);
		},
		upload: function( quirkbotUuid, hexString ){
			return this.adapter.upload(quirkbotUuid, hexString);
		}
	});
})();
</script>
